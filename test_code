import os

def socket_close_rule():
    import socket
    s = socket.socket(
        socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('', 9000))
    s.listen(5)
    while True:
        c, addr = s.accept()
        print('Got connection from', addr)
        c.send(b'Thank you for connecting')
        c.close()

def redundant_Get_Method_Call():
    dict = {"A":1, "B":2}
    val = dict.get("C", None)
    return val

def dict_Get_Default_Value():
    car = {
        "brand": "bmw",
        "model": "X5",
        "year": "2021"
    }
    x = car.get("model")
    return x


def inline_negation_rule():
    if not a is b:
        print(a)
#guru:v1:internal:pythonbestpractices:exit_class_method_re_raise_exception:1.0
class Exit_class_method_re_raise_exception:
    def __enter__(self):
        return self

    def __exit__(self, *args):
        a = 1
        b = 2
        raise
#pythonbestpractices:prefer_secrets_for_prng_for_cryptography_rule
def prefer_secrets_for_prng_for_cryptography_rule():
    # hashlib.md5.update
    # random.choice
    import random
    import hashlib
    complex_str = "abcdefghijklmnopqrstuvwkyz123456789!@#$%^&*()"
    salt = random.choice(complex_str).encode()
    hash_str = hashlib.md5()
    hash_str.update(salt)


def avoid_complex_comprehension_non_compliant_1():
    text = [['bar', 'foo', 'fooba'], ['Rome', 'Madrid', 'Houston'], ['aa', 'bb', 'cc', 'dd']]
    text_3 = [y.upper() for x in text if len(x) == 3 for y in x if y.startswith('f')]


def avoid_complex_comprehension_non_compliant_2():
    text = [['bar', 'foo', 'fooba'], ['Rome', 'Madrid', 'Houston'], ['aa', 'bb', 'cc', 'dd']]
    text_3 = [z.upper() for x in text if len(x) == 3 for y in x for z in y]


def nonconformant_string_join_efficient_concentation():
    mylist = ['first', 'second', 'third', 'other']
    result = ''
    for item in mylist:
        result += item + "\n"
    return result


def non_conformant_variable_initialized_within_loop_efficient_concentation():
    mylist = ['first', 'second', 'third', 'other']
    s = ""
    for item in mylist:
        s += "Hello World" + item
        print(s)


def nonconformant_list2_unnecessary_iteration():
    input_list = set([10, "USA", 20, "RSA"])
    x = 0
    while x < len(input_list):
        y = input_list[x]
        if y == 20:
            print("found country code")
        x += 1


def nonconformant_list3_unnecessary_iteration():
    input_list = set([10, "USA", 20, "RSA"])
    for x in range(len(input_list)):
        y = input_list[x]
        if y == 10:
            print("item found")


def non_conformant_case1_socket_connection_timed_out():
    import socket
    s = socket.socket()
    s.connect(('127.0.0.1', 9000))
    print(s.recv(1024))
    s.close()


def non_conformant_case2_socket_connection_timed_out():
    import socket
    s = socket.create_connection(('127.0.0.1', 9000))
    print(s.recv(1024))
    s.close()


import os


class Animals:
    def __init__(self):
        self.lion = 'carnivore'
        self.dog = 'omnivore'
        self.giraffe = 'herbivore'

    def printit(self):
        print("Dictionary from the object fields\
        belonging to the class Animals:")


def nonconformant_case3_do_not_directly_modify_dict():
    # object animal of class Animals
    animal = Animals()

    # calling printit method
    animal.printit()
    animal.__dict__['lion'] = 'omnivore'


def error_prone_multidimensional_list_non_conformant1():
    multi_dim_list = [[None] * 2] * 3


def error_prone_multidimensional_list_non_conformant2():
    multi_dim_list = [[[1] * 2] * 2]


def error_prone_multidimensional_list_non_conformant3():
    multi_dim_list = [[[[7.55] * 2] * 2]] * 3


def nonconformant_case1_subprocess_communicate_timeout_expires_rule():
    import subprocess
    proc = subprocess.Popen("ls -al", shell=True, bufsize=-1, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    try:
        outs, errs = proc.communicate(timeout=15)
    except subprocess.TimeoutExpired:
        print("Timed out")


class BaseSSLError(BaseException):
    pass
